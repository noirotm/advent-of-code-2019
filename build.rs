// generate file that dynamically instantiates all solutions
use chrono::prelude::*;
use std::{
    error::Error,
    fs::{metadata, read_dir, File},
    io,
    io::Write,
    path::{Path, PathBuf},
    str,
};

fn days(input_dir: &str) -> io::Result<Vec<u32>> {
    Ok(read_dir(input_dir)?
        .flatten()
        .filter(|e| e.path().is_file())
        .flat_map(|e| e.file_name().into_string())
        .flat_map(|s| {
            str::from_utf8(&s.into_bytes()[3..])
                .ok()
                .and_then(|v| v.parse::<u32>().ok())
        })
        .collect())
}

fn is_solutions_mod_outdated<P1, P2>(input_dir: P1, mod_file: P2) -> io::Result<bool>
where
    P1: AsRef<Path>,
    P2: AsRef<Path>,
{
    let meta = metadata(mod_file);
    if let Ok(meta) = meta {
        let mod_mtime = meta.modified()?;

        // if any of the input files is more recent than our module, we are outdated
        let mod_outdated = read_dir(input_dir)?
            .flatten()
            .filter(|e| e.path().is_file())
            .flat_map(|e| e.metadata())
            .flat_map(|m| m.created())
            .any(|input_ctime| input_ctime > mod_mtime);

        Ok(mod_outdated)
    } else {
        // mod file not found, we are outdated
        Ok(true)
    }
}

fn gen_solutions_mod<P: AsRef<Path>>(p: P, days: &[u32]) -> io::Result<()> {
    let mut f = File::create(p)?;
    writeln!(
        f,
        "// DO NOT EDIT THIS FILE - Last generated: {}",
        Utc::now()
    )?;
    writeln!(f, "use crate::solver::Solver;")?;
    writeln!(f)?;
    for day in days {
        writeln!(f, "mod day{0:02};", day)?;
    }
    writeln!(f)?;
    writeln!(
        f,
        "pub fn exec_day(day: i32) {{
    match day {{"
    )?;
    for day in days {
        writeln!(f, "        {0} => day{0:02}::Problem {{}}.solve(day),", day)?;
    }
    writeln!(
        f,
        "        d => println!(\"Day {{}} hasn't been solved yet :(\", d),
    }}
}}"
    )?;

    Ok(())
}

fn gen_solutions(dir: &str, days: &[u32]) -> io::Result<()> {
    for day in days {
        let file = PathBuf::from(format!("{}/day{:02}.rs", dir, day));
        if file.exists() {
            continue;
        }

        let mut f = File::create(file)?;
        writeln!(
            f,
            "use crate::solver::Solver;

struct Problem;

impl Solution for Problem {{
    type Input = ();
    type Output1 = u64;
    type Output2 = u64;

    fn solve_first(&self, input: &Self::Input) -> Self::Output1 {{
        0
    }}

    fn solve_second(&self, input: &Self::Input) -> Self::Output2 {{
        0
    }}
}}"
        )?;
    }

    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    let input_dir = "./input";
    let output_dir = "./src/solutions";
    let solutions_mod_output_path = Path::new(&output_dir).join("mod.rs");

    let days = days(input_dir)?;

    // write solutions mod file
    if is_solutions_mod_outdated(input_dir, &solutions_mod_output_path)? {
        gen_solutions_mod(&solutions_mod_output_path, &days)?;
    }

    // write solutions
    gen_solutions(output_dir, &days)?;

    Ok(())
}
